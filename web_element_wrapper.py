from selenium.webdriver.remote.webelement import WebElement

# TODO: circular import???
import selenium_helper as sel


class WebElementWrapper(WebElement):
    """Represents a DOM element. Extends the parent class to add a few methods."""
    def __init__(self, web_element):
        """
        Constructor. Overrides the parent method to accept an object instead of a set of attributes

        Args:
            web_element (Selenium WebElement object): element object, generated by Selenium find_*() methods
        """
        super().__init__(web_element._parent, web_element._id, web_element._w3c)

    def is_clickable(self):
        """
        Whether the element is clickable (technically, whether it's visible & not disabled)

        Returns:
             bool: True if element is clickable, False otherwise
        """
        return self.is_displayed() and self.is_enabled()

    def click(self, wait=10):
        """
        Wait until the element is clickable, then click it

        Args:
            wait (int, optional): max number of seconds to wait. Defaults to 10.

        Returns:
            WebElementWrapper object: the element itself. Useful for simultaneously clicking & storing the element
        """
        sel.wait_until(self.is_clickable, timeout=wait)
        super().click()
        # TODO: is this weird? this seems weird
        return self

    def replace_text(self, *value):
        """
        Replace the current text in the element

        Args:
            *value (str): string(s) to replace the current text
        """
        self.clear()
        self.send_keys(*value)

    @property
    def value(self):
        """
        The content of the element's "value" attribute.
        Mainly used to get the text in a text field, since that's not "normal" element text.
        """
        return self.get_attribute('value')

    # TODO: 'should' methods - if we have to write our own asserts over for pytest, might as well
