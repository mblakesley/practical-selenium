from selenium.webdriver.remote.webelement import WebElement
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.wait import WebDriverWait

import selenium_helper as sel


class WebElementWrapper(WebElement):
    """Represents a DOM element. Extends the parent class to add a few methods."""
    def __init__(self, web_element):
        """
        Constructor. Overrides the parent method to accept an object instead of a set of attributes

        Args:
            web_element (Selenium WebElement object): element object, generated by Selenium find_*() methods
        """
        super().__init__(web_element._parent, web_element._id, web_element._w3c)

    def find(self, selector, timeout=10):
        """
        Fetch first descendant element matching selector and ensure it's visible.
        If no element matches this criteria, keep rechecking until one does or until timeout is reached.

        Args:
            selector (str OR tuple): either a CSS/XPath selector string OR a Selenium locator tuple
            timeout (int, optional): max number of seconds to wait. Defaults to 10.

        Returns:
            WebElementWrapper object: Selenium element object with added convenience methods
        """
        locator = sel.locatorize(selector)
        elem = self._wait_until(EC.visibility_of_element_located(locator), timeout=timeout)
        return WebElementWrapper(elem)

    def is_clickable(self):
        """
        Whether the element is clickable (technically, whether it's visible & not disabled)

        Returns:
             bool: True if element is clickable, False otherwise
        """
        return self.is_displayed() and self.is_enabled()

    def click(self, timeout=10):
        """
        Wait until element is clickable or timeout is reached. If element is clickable, click it.

        Args:
            timeout (int, optional): max number of seconds to wait. Defaults to 10.
        """
        self._wait_until(self.is_clickable, timeout=timeout)
        super().click()

    def replace_text(self, *value):
        """
        Replace the current text in the element

        Args:
            *value (str): string(s) to replace the current text
        """
        self.clear()
        self.send_keys(*value)

    @property
    def value(self):
        """
        The content of the element's "value" attribute.
        Mainly used to get the text in a text field, since that's not "normal" element text.
        """
        return self.get_attribute('value')

    def _wait_until(self, func, timeout=10, wait_between_calls=0.5):
        """
        Call specified function repeatedly until it returns a truthy value or until timeout is reached.

        Note: This is a special, private implementation for WebElementWrapper. See sel_helper's version for more info.
        """
        wait_obj = WebDriverWait(self, timeout, poll_frequency=wait_between_calls)
        try:
            return wait_obj.until(func)
        except TypeError:
            return wait_obj.until(lambda driver: func())

    # TODO: 'should' methods - if we have to write our own asserts over for pytest, might as well
