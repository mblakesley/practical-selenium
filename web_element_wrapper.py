from selenium.webdriver.remote.webelement import WebElement
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support.select import Select

import selenium_helper as sel


class WebElementWrapper(WebElement):
    """Represents a DOM element. Extends the parent class to add a few methods."""
    def __init__(self, web_element):
        """
        Constructor. Overrides the parent method to accept an object instead of a set of attributes

        Args:
            web_element (Selenium WebElement object): element object, generated by Selenium find_*() methods
        """
        super().__init__(web_element._parent, web_element._id, web_element._w3c)

    def find(self, selector, timeout=10):
        """
        Fetch first descendant element matching selector and ensure it's visible.
        If no elements match this criteria, recheck until one does or until timeout is reached.

        Args:
            selector (str OR tuple): either a CSS/XPath selector string OR a Selenium locator tuple
            timeout (int, optional): max number of seconds to wait. Defaults to 10.

        Returns:
            WebElementWrapper object: Selenium element object with added convenience methods
        """
        locator = sel.locatorize(selector)
        elem = self._wait_until(EC.visibility_of_element_located(locator), timeout=timeout)
        return WebElementWrapper(elem)

    def find_all(self, selector, timeout=10):
        """
        Fetch all visible descendant elements matching selector.
        If none match this criteria, recheck until at least one does or until timeout is reached.

        Args:
            selector (str OR tuple): either a CSS/XPath selector string OR a Selenium locator tuple
            timeout (int, optional): max number of seconds to wait. Defaults to 10.

        Returns:
            list of WebElementWrapper objects: list of Selenium element objects with added convenience methods
        """
        locator = sel.locatorize(selector)
        elem_list = self._wait_until(EC.visibility_of_any_elements_located(locator), timeout=timeout)
        return list(map(WebElementWrapper, elem_list))

    def find_menu(self, selector, timeout=10):
        """
        Fetch first descendant <select> element matching selector and ensure it's visible.
        If no elements match this criteria, recheck until one does or until timeout is reached.

        Args:
            selector (str OR tuple): either a CSS/XPath selector string OR a Selenium locator tuple
            timeout (int, optional): max number of seconds to wait. Defaults to 10.

        Returns:
            WebElementWrapper object: Selenium element object with added convenience methods
        """
        locator = sel.locatorize(selector)
        elem = self._wait_until(EC.visibility_of_element_located(locator), timeout=timeout)
        return Select(elem)

    def find_by_text(self, basic_selector, text, matching_strategy='contains', timeout=10):
        """
        Fetch first descendant element matching selector and containing the specified text and ensure it's visible.
        If no elements match this criteria, recheck until one does or until timeout is reached.

        Note: This method won't work when text is split across parent/child DOM elements

        Args:
            basic_selector (str): selector string for 1 element type, e.g. 'a' or 'tr'. Anything fancier WON'T work
            text (str): text to look for
            matching_strategy ({'contains', 'starts-with'}, optional):
                matching strategy to use on the text check. Defaults to 'contains'.
            timeout (int, optional): max number of seconds to wait. Defaults to 10.

        Returns:
            WebElementWrapper object: Selenium element object with added convenience methods
        """
        # See sel_helper's version for more info on how this works
        full_selector = './/*[{}(text(),"{}")]/ancestor-or-self::{}[1]'.format(
            matching_strategy, text, basic_selector)
        return self.find(full_selector, timeout=timeout)

    def is_clickable(self):
        """
        Whether the element is clickable (technically, whether it's visible & not disabled)

        Returns:
             bool: True if element is clickable, False otherwise
        """
        return self.is_displayed() and self.is_enabled()

    def click(self, timeout=10):
        """
        Wait until element is clickable or timeout is reached. If element is clickable, click it.

        Args:
            timeout (int, optional): max number of seconds to wait. Defaults to 10.
        """
        self._wait_until(self.is_clickable, timeout=timeout)
        super().click()

    def replace_text(self, *value):
        """
        Replace the current text in the element

        Args:
            *value (str): string(s) to replace the current text
        """
        self.clear()
        self.send_keys(*value)

    @property
    def value(self):
        """
        The content of the element's "value" attribute.
        Mainly used to get the text in a text field, since that's not "normal" element text.
        """
        return self.get_attribute('value')

    def _wait_until(self, func, timeout=10, wait_between_calls=0.5):
        """
        Call specified function repeatedly until it returns a truthy value or until timeout is reached.

        Note: This is a special, private implementation for WebElementWrapper. See sel_helper's version for more info.
        """
        wait_obj = WebDriverWait(self, timeout, poll_frequency=wait_between_calls)
        try:
            return wait_obj.until(func)
        except TypeError:
            return wait_obj.until(lambda driver: func())

    # TODO: driver wrapper
    # TODO: extract default timeouts to var
    # TODO: staleness of -> wait_for_nav() like puppeteer? Or something else? "wait until stale" seems weird...
    # TODO: 'should' methods? - if we have to write our own asserts over for pytest, might as well
    # TODO: need our own EC.invisibility_of_all??
